#+TITLE: Ashfaq Farooqui's Emacs Configuration
#+AUTHOR: Ashfaq Farooqui
#+EMAIL: ashfaq.farooqui@gmail.com
#+OPTIONS: toc:3 num:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />

* User Details
#+begin_src emacs-lisp
     (setq user-full-name "Ashfaq Farooqui")
     (setq user-mail-address "ashfaq.farooqui@gmail.com")
#+end_src
* Package Management
Since Emacs 24, Emacs includes the Emacs Lisp Package Archive
([[http://www.emacswiki.org/emacs/ELPA][ELPA]]) by default. This provides a nice way to install additional
packages. Since the default package archive doesn't include
everything necessary, the [[http://marmalade-repo.org/][marmalade]], and [[http://melpa.milkbox.net/#][melpa]] repositories are also
added.
#+begin_src emacs-lisp
     (load "package")
    (package-initialize)
    (add-to-list 'package-archives
                 '("marmalade" . "http://marmalade-repo.org/packages/"))
    (add-to-list 'package-archives
                 '("melpa" . "http://melpa.milkbox.net/packages/") t)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
    (add-to-list 'package-archives
                '("elpy" . "http://jorgenschaefer.github.io/packages/"))
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
    (setq package-archive-enable-alist '(("melpa" magit f)))
    (require 'cl)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+end_src

#+RESULTS:
: use-package

* Some mandatory stuff
** Adding default folders
#+BEGIN_SRC emacs-lisp
(defvar my/emacs-cache (concat user-emacs-directory ".cache/")
  "Folder to store cache files in.

Should end with a forward slash.")

(setq custom-file (concat my/emacs-cache "customize.el"))
(setq bookmark-default-file (concat my/emacs-cache "bookmarks"))
(setq recentf-save-file (concat my/emacs-cache "recentf"))

#+END_SRC
** Splash Screen

I want to skip straight to the scratch buffer. This turns off the
splash screen and puts me straight into the scratch buffer. I
don't really care to have anything in there either, so turn off
the message while we're at it. Since I end up using =org-mode=
most of the time, set the default mode accordingly.

#+begin_src emacs-lisp
      (setq inhibit-splash-screen t
            initial-scratch-message nil
            initial-major-mode 'org-mode)
#+end_src
** Scroll bar, Tool bar, Menu bar
Emacs starts up with way too much enabled. Configure the scroll bar,
menu bar, and tool bar. There isn't really a reason to have them
on.
#+begin_src emacs-lisp
      (scroll-bar-mode -1)
      (tool-bar-mode -1)
      (menu-bar-mode 1)
#+end_src
** Marking text
There are some behaviors in Emacs that aren't intuitive. Since I
pair with others that don't know how Emacs handles highlighting,
treat regions like other text editors. This means typing when the
mark is active will write over the marked region. Also, make the
common highlighting keystrokes work the way most people expect
them to. This saves a lot of time explaining how to highlight
areas of text. Emacs also has it's own clipboard and doesn't
respond to the system clipboard by default, so tell Emacs that
we're all friends and can get along.
#+begin_src emacs-lisp
      (delete-selection-mode t)
      (transient-mark-mode t)
      (setq x-select-enable-clipboard t)
#+end_src
** Display Settings
I have some modifications to the default display. First, a
minor tweak to the frame title. It's also nice to be able to see
when a file actually ends. This will put empty line markers into
the left hand side.
#+begin_src emacs-lisp
      (setq-default indicate-empty-lines t)
      (when (not indicate-empty-lines)
        (toggle-indicate-empty-lines))
#+end_src
** Indentation
There's nothing I dislike more than tabs in my files. Make sure I
don't share that discomfort with others.
#+begin_src emacs-lisp
   (setq tab-width 4
         indent-tabs-mode nil)
#+end_src
** Backup files
Save backups in another folder
#+begin_src emacs-lisp
(setq
 backup-by-copying t     ; don't clobber symlinks
 kept-new-versions 10    ; keep 10 latest versions
 kept-old-versions 0     ; don't bother with old versions
 delete-old-versions t   ; don't ask about deleting old versions
 version-control t       ; number backups
 vc-make-backup-files t ; backup version controlled files
 backup-directory-alist
        '(("." . "~/.emacs.d/backups/emacs-saves"))   ; don't litter my fs tree
   auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 20            ; number of keystrokes between auto-saves (default: 300)

)

 (setq auto-mode-alist
      (append
       (list
        '("\\.\\(vcf\\|gpg\\)$" . sensitive-minor-mode)
        )
       auto-mode-alist))
;;http://pragmaticemacs.com/emacs/auto-save-and-backup-every-save/
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; backup every save                                                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; http://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files
;; https://www.emacswiki.org/emacs/backup-each-save.el
(defvar bjm/backup-file-size-limit (* 10 1024 1024)
  "Maximum size of a file (in bytes) that should be copied at each savepoint.

If a file is greater than this size, don't make a backup of it.
Default is 5 MB")

(defvar bjm/backup-location (expand-file-name "~/.emacs.d/emacs-backups")
  "Base directory for backup files.")

(defvar bjm/backup-trash-dir (expand-file-name "~/.Trash")
  "Directory for unwanted backups.")

(defvar bjm/backup-exclude-regexp "\\[Gmail\\]"
  "Don't back up files matching this regexp.

Files whose full name matches this regexp are backed up to `bjm/backup-trash-dir'. Set to nil to disable this.")

;; Default and per-save backups go here:
;; N.B. backtick and comma allow evaluation of expression
;; when forming list
(setq backup-directory-alist
      `(("" . ,(expand-file-name "per-save" bjm/backup-location))))

;; add trash dir if needed
(if bjm/backup-exclude-regexp
    (add-to-list 'backup-directory-alist `(,bjm/backup-exclude-regexp . ,bjm/backup-trash-dir)))

(defun bjm/backup-every-save ()
  "Backup files every time they are saved.

Files are backed up to `bjm/backup-location' in subdirectories \"per-session\" once per Emacs session, and \"per-save\" every time a file is saved.

Files whose names match the REGEXP in `bjm/backup-exclude-regexp' are copied to `bjm/backup-trash-dir' instead of the normal backup directory.

Files larger than `bjm/backup-file-size-limit' are not backed up."

  ;; Make a special "per session" backup at the first save of each
  ;; emacs session.
  (when (not buffer-backed-up)
    ;;
    ;; Override the default parameters for per-session backups.
    ;;
    (let ((backup-directory-alist
           `(("." . ,(expand-file-name "per-session" bjm/backup-location))))
          (kept-new-versions 3))
      ;;
      ;; add trash dir if needed
      ;;
      (if bjm/backup-exclude-regexp
          (add-to-list
           'backup-directory-alist
           `(,bjm/backup-exclude-regexp . ,bjm/backup-trash-dir)))
      ;;
      ;; is file too large?
      ;;
      (if (<= (buffer-size) bjm/backup-file-size-limit)
          (progn
            (message "Made per session backup of %s" (buffer-name))
            (backup-buffer))
        (message "WARNING: File %s too large to backup - increase value of bjm/backup-file-size-limit" (buffer-name)))))
  ;;
  ;; Make a "per save" backup on each save.  The first save results in
  ;; both a per-session and a per-save backup, to keep the numbering
  ;; of per-save backups consistent.
  ;;
  (let ((buffer-backed-up nil))
    ;;
    ;; is file too large?
    ;;
    (if (<= (buffer-size) bjm/backup-file-size-limit)
        (progn
          (message "Made per save backup of %s" (buffer-name))
          (backup-buffer))
      (message "WARNING: File %s too large to backup - increase value of bjm/backup-file-size-limit" (buffer-name)))))

;; add to save hook
(add-hook 'before-save-hook 'bjm/backup-every-save)


#+end_src
** Yes and No
Nobody likes to have to type out the full yes or no when Emacs
asks. Which it does often. Make it one character.
#+begin_src emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

#+RESULTS:
: yes-or-no-p

** Misc
Turn down the time to echo keystrokes so I don't have to wait
around for things to happen. Dialog boxes are also a bit annoying,
so just have Emacs use the echo area for everything. Beeping is
for robots, and I am not a robot. Use a visual indicator instead
of making horrible noises. Oh, and always highlight parentheses. A
person could go insane without that.
#+begin_src emacs-lisp
    (setq echo-keystrokes 0.1
          use-dialog-box nil
          visible-bell t)
    (show-paren-mode t)
  (global-hl-line-mode)
(blink-cursor-mode -1)


(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
      (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))

(add-hook 'text-mode-hook #'dubcaps-mode)
(add-hook 'LaTeX-mode-hook #'dubcaps-mode)
#+end_src
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra 
  :ensure t)

#+END_SRC
** Indentation and buffer cleanup
Setup org mode indentation
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(use-package aggressive-indent
  :ensure t
  :config
  (global-aggressive-indent-mode)
  )
#+END_SRC
This re-indents, untabifies, and cleans up whitespace. It is stolen
directly from the emacs-starter-kit.
#+begin_src emacs-lisp
      (defun untabify-buffer ()
        (interactive)
        (untabify (point-min) (point-max)))

      (defun indent-buffer ()
        (interactive)
        (indent-region (point-min) (point-max)))

      (defun cleanup-buffer ()
        "Perform a bunch of operations on the whitespace content of a buffer."
        (interactive)
        (indent-buffer)
        (untabify-buffer)
        (delete-trailing-whitespace))

      (defun cleanup-region (beg end)
        "Remove tmux artifacts from region."
        (interactive "r")
        (dolist (re '("\\\\│\·*\n" "\W*│\·*"))
          (replace-regexp re "" nil beg end)))

      (global-set-key (kbd "C-x M-t") 'cleanup-region)
      (global-set-key (kbd "C-c n") 'cleanup-buffer)

      (setq-default show-trailing-whitespace t)
#+end_src

Indent stuff, copied from [[https://www.emacswiki.org/emacs/IndentingText]]

#+BEGIN_SRC emacs-lisp
 (defun shift-region (distance)
  (let ((mark (mark)))
    (save-excursion
      (indent-rigidly (region-beginning) (region-end) distance)
      (push-mark mark t t)
      ;; Tell the command loop not to deactivate the mark
      ;; for transient mark mode
      (setq deactivate-mark nil))))

(defun shift-right ()
  (interactive)
  (shift-region 1))

(defun shift-left ()
  (interactive)
  (shift-region -1))

;; Bind (shift-right) and (shift-left) function to your favorite keys. I use
;; the following so that Ctrl-Shift-Right Arrow moves selected text one
;; column to the right, Ctrl-Shift-Left Arrow moves selected text one
;; column to the left:

(global-set-key [C-S-right] 'shift-right)
(global-set-key [C-S-left] 'shift-left)
#+END_SRC
** Hungry delete
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
:ensure t
:config (global-hungry-delete-mode))

#+END_SRC
** Sudo edit
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
:ensure t)

#+END_SRC
** Rainbow delimites
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
:ensure t
:init (rainbow-mode))

(use-package rainbow-delimiters
:ensure t
:config
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
(add-hook 'text-mode-hook #'rainbow-delimiters-mode)
(add-hook 'org-mode-hook #'rainbow-delimiters-mode)
)
#+END_SRC
** Some additions ones
- Open in current window
- Enable cycling camelcase
#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)

(global-subword-mode 1)
#+END_SRC
* Elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    (:map elfeed-search-mode-map
          ("s" . bjm/elfeed-load-db-and-open)
          ("q" . bjm/elfeed-save-db-and-bury))
    :init
    ;; thanks - http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/
    ;; though slightly modified
    ;; functions to support syncing .elfeed between machines
    ;; makes sure elfeed reads index from disk before launching
    (defun bjm/elfeed-load-db-and-open ()
      "Load the elfeed db from disk before opening."
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force)
      (elfeed-update))
    ;;write to disk when quiting
    (defun bjm/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))
    :config
    (setq elfeed-db-directory "~/Dropbox/.elfeed")
    ;; This lets me get the http links to entries with org-capture
    ;; easily.
    (defun elfeed-entry-as-html-link ()
      "Store an http link to an elfeed entry"
      (when (equal major-mode 'elfeed-show-mode)
        (let ((description (elfeed-entry-title elfeed-show-entry))
              (link (elfeed-entry-link elfeed-show-entry)))
          (org-store-link-props
           :type "http"
           :link link
           :description description))))
 ;(org-link-set-parameters "elfeed" :follow #'browse-url :store #'elfeed-entry-as-html-link)
)
 
  (use-package elfeed-goodies
  :ensure t)


  (use-package elfeed-org
    :ensure t
    :config
    (progn
      (elfeed-org)
      (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))))
#+END_SRC

* PDF tools 
https://github.com/abo-abo/hydra/wiki/PDF-Tools
#+BEGIN_SRC emacs-lisp
 (use-package pdf-tools
    :ensure t
    :magic ("%PDF" . pdf-view-mode)
    :commands pdf-tools-install
    :config
    (pdf-tools-install)
    (setq-default pdf-view-display-size 'fit-page))
     (use-package org-pdfview
       :ensure t)
#+END_SRC

#+RESULTS:

Hydra
#+BEGIN_SRC emacs-lisp
(defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                      ╭───────────┐
       Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
   ╭──────────────────────────────────────────────────────────────────┴───────────╯
         ^^_g_^^      _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search    [_u_] revert buffer
         ^^^↑^^^      ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline   [_i_] info
         ^^_p_^^      ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link      [_d_] dark mode
         ^^^↑^^^      ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link
    _h_ ←pag_e_→ _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
         ^^^↓^^^      ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
         ^^_n_^^      ^ ^  _r_eset slice box
         ^^^↓^^^
         ^^_G_^^
   --------------------------------------------------------------------------------
        "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-dark-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ;;("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red))


(global-set-key (kbd "C-c h d") 'hydra-pdftools/body)

#+END_SRC

* Ace-window
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :init
  (progn
    (global-set-key [remap other-window] 'ace-window)
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 3.0))))) 
    ))

(defhydra hydra-frame-window ()
   "
Movement^^        ^Split^         ^Switch^		^Resize^
----------------------------------------------------------------
_h_ ←       	_v_ertical    	_b_uffer		_q_ X←
_j_ ↓        	_x_ horizontal	_f_ind files	_w_ X↓
_k_ ↑        	_z_ undo      	_a_ce 1		_e_ X↑
_l_ →        	_Z_ reset      	_s_wap		_r_ X→
_F_ollow		_D_lt Other   	_S_ave		max_i_mize
\n_SPC_ cancel	_o_nly this   	_d_elete	
"
   ("h" windmove-left )
   ("j" windmove-down )
   ("k" windmove-up )
   ("l" windmove-right )
   ("q" hydra-move-splitter-left)
   ("w" hydra-move-splitter-down)
   ("e" hydra-move-splitter-up)
   ("r" hydra-move-splitter-right)
   ("b" helm-mini)
   ("f" helm-find-files)
   ("F" follow-mode)
   ("a" (lambda ()
          (interactive)
          (ace-window 1)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
       )
   ("v" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right))
       )
   ("x" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down))
       )
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("S" save-buffer)
   ("d" delete-window)
   ("D" (lambda ()
          (interactive)
          (ace-window 16)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
       )
   ("o" delete-other-windows)
   ("i" ace-maximize-window)
   ("z" (progn
          (winner-undo)
          (setq this-command 'winner-undo))
   )
   ("Z" winner-redo)
   ("SPC" nil)
   )


(global-set-key (kbd "C-c h w") 'hydra-frame-window/body)
#+END_SRC

#+RESULTS:
: hydra-window/body

* Helm
#+BEGIN_SRC emacs-lisp
(setq helm-display-function 'helm-display-buffer-in-own-frame
        helm-display-buffer-reuse-frame t
        helm-use-undecorated-frame-option t)


(use-package helm
:ensure t
:config
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x C-f") #'helm-find-files)
(helm-mode 1))
#+END_SRC
* Ibuffer
#+BEGIN_SRC emacs-lisp

  (use-package ibuffer
    :ensure t
    :config 
  (progn (setq ibuffer-saved-filter-groups
               (quote (("default"
                        ("dired" (mode . dired-mode))
                        ("org" (name . "^.*org$"))
                        ("web" (or (mode . web-mode) (mode . js2-mode)))
                        ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
                          ("latex" (or (mode . latex-mode) (name . "^.*tex$") (filename . "ShareLaTeX") ))
                          ("mu4e" (or
                                 (mode . mu4e-compose-mode)
                                 (name . "\*mu4e\*")
                                 ))
                        ("programming" (or
                                        (mode . python-mode)
                                        (mode . c++-mode))
                         (mode . scala-mode)
                         (mode . haskell-mode))
("Magit" (name . "\*magit"))
("emacs-config" (or (filename . ".emacs.d")
			     (filename . "emacs-config")))

                        ("emacs" (or
                                  (name . "^\\*scratch\\*$")
                                  (name . "^\\*Messages\\*$")))
                        ))))
         (add-hook 'ibuffer-mode-hook
                   (lambda ()
                     (ibuffer-auto-mode 1)
                     (ibuffer-switch-to-saved-filter-groups "default"))))
(setq ibuffer-show-empty-filter-groups nil)

)
  (defalias 'list-buffers 'ibuffer-other-window)



#+END_SRC

** hydra ibuf
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-ibuffer-main (:color pink :hint nil)
    "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
    _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
    ("j" ibuffer-forward-line)
    ("RET" ibuffer-visit-buffer :color blue)
    ("k" ibuffer-backward-line)

    ("m" ibuffer-mark-forward)
    ("u" ibuffer-unmark-forward)
    ("*" hydra-ibuffer-mark/body :color blue)

    ("D" ibuffer-do-delete)
    ("S" ibuffer-do-save)
    ("a" hydra-ibuffer-action/body :color blue)

    ("g" ibuffer-update)
    ("s" hydra-ibuffer-sort/body :color blue)
    ("/" hydra-ibuffer-filter/body :color blue)

    ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
    ("q" quit-window "quit ibuffer" :color blue)
    ("." nil "toggle hydra" :color blue))

  (defhydra hydra-ibuffer-mark (:color teal :columns 5
                                :after-exit (hydra-ibuffer-main/body))
    "Mark"
    ("*" ibuffer-unmark-all "unmark all")
    ("M" ibuffer-mark-by-mode "mode")
    ("m" ibuffer-mark-modified-buffers "modified")
    ("u" ibuffer-mark-unsaved-buffers "unsaved")
    ("s" ibuffer-mark-special-buffers "special")
    ("r" ibuffer-mark-read-only-buffers "read-only")
    ("/" ibuffer-mark-dired-buffers "dired")
    ("e" ibuffer-mark-dissociated-buffers "dissociated")
    ("h" ibuffer-mark-help-buffers "help")
    ("z" ibuffer-mark-compressed-file-buffers "compressed")
    ("b" hydra-ibuffer-main/body "back" :color blue))

  (defhydra hydra-ibuffer-action (:color teal :columns 4
                                  :after-exit
                                  (if (eq major-mode 'ibuffer-mode)
                                      (hydra-ibuffer-main/body)))
    "Action"
    ("A" ibuffer-do-view "view")
    ("E" ibuffer-do-eval "eval")
    ("F" ibuffer-do-shell-command-file "shell-command-file")
    ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
    ("H" ibuffer-do-view-other-frame "view-other-frame")
    ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
    ("M" ibuffer-do-toggle-modified "toggle-modified")
    ("O" ibuffer-do-occur "occur")
    ("P" ibuffer-do-print "print")
    ("Q" ibuffer-do-query-replace "query-replace")
    ("R" ibuffer-do-rename-uniquely "rename-uniquely")
    ("T" ibuffer-do-toggle-read-only "toggle-read-only")
    ("U" ibuffer-do-replace-regexp "replace-regexp")
    ("V" ibuffer-do-revert "revert")
    ("W" ibuffer-do-view-and-eval "view-and-eval")
    ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
    ("b" nil "back"))

  (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
    "Sort"
    ("i" ibuffer-invert-sorting "invert")
    ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
    ("v" ibuffer-do-sort-by-recency "recently used")
    ("s" ibuffer-do-sort-by-size "size")
    ("f" ibuffer-do-sort-by-filename/process "filename")
    ("m" ibuffer-do-sort-by-major-mode "mode")
    ("b" hydra-ibuffer-main/body "back" :color blue))

  (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
    "Filter"
    ("m" ibuffer-filter-by-used-mode "mode")
    ("M" ibuffer-filter-by-derived-mode "derived mode")
    ("n" ibuffer-filter-by-name "name")
    ("c" ibuffer-filter-by-content "content")
    ("e" ibuffer-filter-by-predicate "predicate")
    ("f" ibuffer-filter-by-filename "filename")
    (">" ibuffer-filter-by-size-gt "size")
    ("<" ibuffer-filter-by-size-lt "size")
    ("/" ibuffer-filter-disable "disable")
    ("b" hydra-ibuffer-main/body "back" :color blue))


  (define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)
(add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
#+END_SRC

#+RESULTS:
| hydra-ibuffer-main/body |
* Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC
* Which key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config 
(progn 
(which-key-mode)
(which-key-setup-side-window-bottom)
(setq which-key-allow-evil-operators t)
(setq which-key-show-operator-state-maps t)))

#+END_SRC
* Graphviz
#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
:ensure t)

#+END_SRC
* Org
#+BEGIN_SRC emacs-lisp
(use-package org
:ensure org-plus-contrib
:pin org)
(use-package org-bullets
:ensure t)
#+END_SRC

#+RESULTS:

=org-mode= is one of the most powerful and amazing features of
Emacs. I mostly use it for task/day organization and generating
code snippets in HTML. Just a few tweaks here to make the
experience better.
** modules
#+BEGIN_SRC emacs-lisp
; Enable habit tracking (and a bunch of other modules)
 (add-to-list 'org-modules 'org-habit t)
; position the habit graph on the agenda to the right of the default
(setq org-habit-graph-column 50)
#+END_SRC

#+RESULTS:
: 50

** Directory setup
Store my org files in =~/Orgs=, define an index file and an
archive of finished tasks in =archive.org=.

#+BEGIN_SRC emacs-lisp
 (setq org-directory "~/Orgs")

 (defun org-file-path (filename)
   "Return the absolute address of an org file, given its relative name."
   (concat (file-name-as-directory org-directory) filename))

 (setq org-inbox-file
       (concat (org-file-path "inbox.org")))
 (setq org-index-file (org-file-path "index.org"))
 (setq org-archive-location
       (concat (org-file-path "archive.org") "::* From %s"))

#+END_SRC
** Settings
*** Sequences
#+begin_src emacs-lisp
                 (setq org-todo-keywords '((sequence
                     "TODO(t)"  ; next action
                     "NEXT(s)"
                     "WAITING(w@/!)"
                     "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
                    (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")
                     (sequence "IDEA"))
         org-todo-keyword-faces '(("IDEA" . (:foreground "green" :weight bold))
                                       ("NEXT" . (:foreground "blue" :weight bold))
                                       ("CANCELLED" . (:foreground "red" :weight book))
                                       ("SOMEDAY" . (:foreground "red" :weight book))
                                       ("WAITING" . (:foreground "yellow" :weight book))
                                       ("COMPLETE" . (:foreground "green" :weight bold))
                                       ("DONE" . (:foreground "green" :weight bold))))



                   (setq org-log-done t)
                      (add-hook 'org-mode-hook
                                (lambda ()
                                  (flyspell-mode)))
                      (add-hook 'org-mode-hook
                                (lambda ()
                                  (writegood-mode)))
    (add-hook 'LaTeX-mode-hook (lambda () (writegood-mode)))
  (add-hook 'LaTeX-mode-hook (lambda () (flyspell-mode)))

(setq org-use-fast-todo-selection t)
(setq org-treat-S-cursor-todo-selection-as-state-change nil)


(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+end_src

#+RESULTS:

*** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (org-bullets-mode t)))
#+END_SRC

#+RESULTS:

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

When I'm starting an org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

some more misc settings
#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities          t ; UTF8 all the things!
      org-support-shift-select     t ; holding shift and moving point should select things
      org-M-RET-may-split-line     nil ; M-RET may never split a line
      org-enforce-todo-dependencies t ; can't finish parent before children
      org-enforce-todo-checkbox-dependencies t ; can't finish parent before children
      org-hide-emphasis-markers t ; make words italic or bold, hide / and *
      org-catch-invisible-edits 'error ; don't let me edit things I can't see
      org-startup-indented t) ; start with indentation setup
(setq org-startup-with-inline-images t) ; show inline images
(setq org-log-done t)
(setq org-goto-interface (quote outline-path-completion))
(use-package htmlize
  :ensure t)
(setq org-special-ctrl-a/e t)
#+END_SRC
** Org-tags
#+BEGIN_SRC emacs-lisp
; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            ("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?H)
                            (:endgroup)
                            ("WAITING" . ?w)
                            ("HOLD" . ?h)
                            ("PERSONAL" . ?P)
                            ("WORK" . ?W)
                            ("ORG" . ?O)
                            ("crypt" . ?E)
                            ("NOTE" . ?n)
                            ("CANCELLED" . ?c)
                            ("FLAGGED" . ??))))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)

#+END_SRC

#+RESULTS:
: t

** org-babel
=org-babel= is a feature inside of =org-mode= that makes this
document possible. It allows for embedding languages inside of an
=org-mode= document with all the proper font-locking. It also
allows you to extract and execute code. It isn't aware of
=Clojure= by default, so the following sets that up.
#+begin_src emacs-lisp
  (use-package ob-async
    :ensure t)
  (require 'ox-latex)

  (setq org-latex-create-formula-image-program 'dvipng)
  (require 'ob)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (dot . t)
     (ruby . t)
     (js . t)
     (C . t)
     (latex . t)
     (ledger .t)
                                          ;    (scala . t)
     (python . t)
                                          ;    (ipython . t)
     ))

       (add-to-list 'org-src-lang-modes (quote ("dot". graphviz-dot)))
       (add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))

       (defvar org-babel-default-header-args:clojure
         '((:results . "silent") (:tangle . "yes")))

       (defun org-babel-execute:clojure (body params)
         (lisp-eval-string body)
         "Done!")

       (provide 'ob-clojure)

       (setq org-src-fontify-natively t
             org-confirm-babel-evaluate nil)

       (add-hook 'org-babel-after-execute-hook (lambda ()
                                                 (condition-case nil
                                                     (org-display-inline-images)
                                                   (error nil)))
                 'append)

(add-to-list 'org-latex-packages-alist
             '("" "tikz" t))

(eval-after-load "preview"
  '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))
#+end_src

#+RESULTS:
: (\RequirePackage[ (, . preview-default-option-list) ]{preview}[2004/11/05] \PreviewEnvironment{tikzpicture})

-latex-classes '("koma-letter" "\\documentclass{scrlttr2}
  [NO-DEFAULT-PACKAGES]"))

  (use-package ox
    :ensure org
    :co
** org-refile
from http://doc.norang.ca/org-mode.html#Refiling
#+BEGIN_SRC emacs-lisp
; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))

; Use full outline paths for refile targets - we file directly with IDO
(setq org-refile-use-outline-path t)

; Targets complete directly with IDO
(setq org-outline-path-complete-in-steps nil)

; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

(setq org-indirect-buffer-display 'current-window)

;;;; Refile settings
; Exclude DONE state tasks from refile targets
(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'bh/verify-refile-target)

#+END_SRC

#+RESULTS:
: bh/verify-refile-target

** org-agenda
Use all the files to derive agenda.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-directory))
  (setq org-agenda-include-diary t)
  (setq org-agenda-include-all-todo t)

;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Custom agenda command definitions
(setq org-agenda-custom-commands
      (quote (("N" "Notes" tags "NOTE"
               ((org-agenda-overriding-header "Notes")
                (org-tags-match-list-sublevels t)))
              ("h" "Habits" tags-todo "STYLE=\"habit\""
               ((org-agenda-overriding-header "Habits")
                (org-agenda-sorting-strategy
                 '(todo-state-down effort-up category-keep))))
              (" " "Agenda"
               ((agenda "" nil)
                (tags "REFILE"
                      ((org-agenda-overriding-header "Tasks to Refile")
                       (org-tags-match-list-sublevels nil)))
                (tags-todo "-CANCELLED/!"
                           ((org-agenda-overriding-header "Stuck Projects")
                            (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-HOLD-CANCELLED/!"
                           ((org-agenda-overriding-header "Projects")
                            (org-agenda-skip-function 'bh/skip-non-projects)
                            (org-tags-match-list-sublevels 'indented)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED/!NEXT"
                           ((org-agenda-overriding-header (concat "Project Next Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                            (org-tags-match-list-sublevels t)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(todo-state-down effort-up category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Project Subtasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Standalone Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED+WAITING|HOLD/!"
                           ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-tasks)
                            (org-tags-match-list-sublevels nil)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))
                (tags "-REFILE/"
                      ((org-agenda-overriding-header "Tasks to Archive")
                       (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
                       (org-tags-match-list-sublevels nil))))
               nil))))


(setq org-habit-graph-column 50)
;; Use sticky agenda's so they persist
(setq org-agenda-sticky t)
;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
              (todo category-up effort-up)
              (tags category-up effort-up)
              (search category-up))))

;; Start the weekly agenda on Monday
(setq org-agenda-start-on-weekday 1)

;; Enable display of the time grid so we can see the marker for the current time
(setq org-agenda-time-grid (quote ((daily today remove-match)
                                   #("----------------" 0 16 (org-heading t))
                                   (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)

;;
;; Agenda sorting functions
;;
(setq org-agenda-cmp-user-defined 'bh/agenda-sort)

(defun bh/agenda-sort (a b)
  "Sorting strategy for agenda items.
Late deadlines first, then scheduled, then non-late deadlines"
  (let (result num-a num-b)
    (cond
     ; time specific items are already sorted first by org-agenda-sorting-strategy

     ; non-deadline and non-scheduled items next
     ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

     ; deadlines for today next
     ((bh/agenda-sort-test 'bh/is-due-deadline a b))

     ; late deadlines next
     ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))

     ; scheduled items for today next
     ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

     ; late scheduled items next
     ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

     ; pending deadlines last
     ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

     ; finally default to unsorted
     (t (setq result nil)))
    result))

(defmacro bh/agenda-sort-test (fn a b)
  "Test for agenda sort"
  `(cond
    ; if both match leave them unsorted
    ((and (apply ,fn (list ,a))
          (apply ,fn (list ,b)))
     (setq result nil))
    ; if a matches put a first
    ((apply ,fn (list ,a))
     (setq result -1))
    ; otherwise if b matches put b first
    ((apply ,fn (list ,b))
     (setq result 1))
    ; if none match leave them unsorted
    (t nil)))

(defmacro bh/agenda-sort-test-num (fn compfn a b)
  `(cond
    ((apply ,fn (list ,a))
     (setq num-a (string-to-number (match-string 1 ,a)))
     (if (apply ,fn (list ,b))
         (progn
           (setq num-b (string-to-number (match-string 1 ,b)))
           (setq result (if (apply ,compfn (list num-a num-b))
                            -1
                          1)))
       (setq result -1)))
    ((apply ,fn (list ,b))
     (setq result 1))
    (t nil)))

(defun bh/is-not-scheduled-or-deadline (date-str)
  (and (not (bh/is-deadline date-str))
       (not (bh/is-scheduled date-str))))

(defun bh/is-due-deadline (date-str)
  (string-match "Deadline:" date-str))

(defun bh/is-late-deadline (date-str)
  (string-match "\\([0-9]*\\) d\. ago:" date-str))

(defun bh/is-pending-deadline (date-str)
  (string-match "In \\([^-]*\\)d\.:" date-str))

(defun bh/is-deadline (date-str)
  (or (bh/is-due-deadline date-str)
      (bh/is-late-deadline date-str)
      (bh/is-pending-deadline date-str)))

(defun bh/is-scheduled (date-str)
  (or (bh/is-scheduled-today date-str)
      (bh/is-scheduled-late date-str)))

(defun bh/is-scheduled-today (date-str)
  (string-match "Scheduled:" date-str))

(defun bh/is-scheduled-late (date-str)
  (string-match "Sched\.\\(.*\\)x:" date-str))
#+END_SRC

#+RESULTS:
: bh/is-scheduled-late

** Ending tasks
Mark a =TODO= as done using =C-c C-x C-s= and send to archive.
#+BEGIN_SRC emacs-lisp
(defun mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo "DONE")
  (org-archive-subtree))

(define-key global-map "\C-c\C-x\C-s" 'mark-done-and-archive)
(setq org-log-done 'time)
#+END_SRC

#+RESULTS:
: time

** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =blog-ideas.org=,
- Record everything related to Phd stuff in =~/Phd Notebook.org=, and
- Maintain a todo list in =to-do.org=.
- Maintain a reading list in =to-read.org=

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        (quote ( ("a" "Appointment" entry (file  (org-file-path "gcal.org"))
                  "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")

                 ("t" "todo work" entry (file+headline "Phd.org" "Tasks")
                  "* TODO %a %?\nSCHEDULE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))")

                 ("b" "Blog idea"
                  entry
                  (file (org-file-path "blog-ideas.org"))
                  "* TODO %?\n")

                 ("p" "Phd Notes"
                  entry
                  (file (org-file-path "Phd.org")))

                 ("N" "Notes"
                  entry
                  (file org-index-file)
                  "* %? :NOTE:\n")
                 ("i" "Inbox"
                  entry
                  (file org-index-file)
                  "* TODO %?\nSCHEDULED: %^{Scheduled to begin}t DEADLINE:
  %^{Deadline}T\n")
("r" "respond" entry (file org-index-file)
               "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
("h" "Habit" entry (file org-index-file)
               "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")
)))

  ;; (setq ledger-expense-completions
  ;;      (list
  ;;       "" ;; needed for first | for mapconcat
  ;;       "Income:Salary"
  ;;       "Assets:Savings" "Assets:Checking"
  ;;       "Expenses:Dining" "Expenses:ToIndia" "Expenses:Additional" "Expenses:Groceries" "Expenses:Rent" "Expenses:Outfit:Apparel" "Expenses:Outfit:Accessories" "Expenses:Goods" "Expenses:Electronics:Gadgets" "Expenses:Phone" "Expenses:Tools" "Expenses:Transport" "Expenses:Entertainment"
  ;;       "Liabilities:ChalmersCard"
  ;;       ))
  ;;
  ;;
  ;;   (setq capture-expense-template
  ;;         "%%(org-read-date) * %%^{What}
  ;;       %%^{Expenses%s}  %%^{Amount}
  ;;       %%^{Assets%s}")
  ;;
  ;;   (setq capture-income-template
  ;;         "%%(org-read-date) * Salary
  ;;       Assets:Checking  %%^{Amount}
  ;;       Income:Salary")
  ;;
  ;;   (setq capture-credit-template
  ;;         "%%(org-read-date) * %%^{What}
  ;;       %%^{Expense%s}  %%^{Amount}
  ;;       Liabilities:ChalmersCard")
  ;;
  ;;   (setq capture-transfer-template
  ;;         "%%(org-read-date) * %%^{What}
  ;;       %%^{Assets%s}  %%^{Amount}
  ;;       %%^{Assets%s}")
  ;;
  ;;defun return-capture-expense-template ()
  ;;   (let ((compstring
  ;;          (mapconcat 'identity ledger-expense-completions  "|" )))
  ;; (format capture-expense-template compstring compstring)))
  ;;
  ;;defun return-capture-credit-template ()
  ;;   (let ((compstring
  ;;          (mapconcat 'identity ledger-expense-completions  "|" )))
  ;; (format capture-credit-template compstring compstring))
  ;; )
  ;;defun return-capture-income-template ()
  ;;   (let ((compstring
  ;;          (mapconcat 'identity ledger-expense-completions  "|" )))
  ;; (format capture-income-template compstring compstring))
  ;; )
  ;;defun return-capture-transfer-template ()
  ;;   (let ((compstring
  ;;          (mapconcat 'identity ledger-expense-completions  "|" )))
  ;; (format capture-transfer-template compstring compstring))
  ;; )
  ;;
  ;;setq org-capture-templates
  ;;       (append '(("l" "Ledger entries")
  ;;                 ("ls" "Spending" plain
  ;;                 (file "~/Dropbox/orgs/Accounts/finances.ledger")
  ;;                 (function return-capture-expense-template)
  ;;                 :empty-lines-before 1
  ;;                 :empty-lines-after 1)
  ;;                 ("lc" "Credit" plain
  ;;                 (file "~/Dropbox/orgs/Accounts/finances.ledger")
  ;;                 (function return-capture-credit-template)
  ;;                 :empty-lines-before 1
  ;;                 :empty-lines-after 1)
  ;;                 ("li" "Income" plain
  ;;                 (file "~/Dropbox/orgs/Accounts/finances.ledger")
  ;;                 (function return-capture-income-template)
  ;;                 :empty-lines-before 1
  ;;                 :empty-lines-after 1)
  ;;                 ("lt" "Transfer" plain
  ;;                 (file "~/Dropbox/orgs/Accounts/finances.ledger")
  ;;                 (function return-capture-transfer-template)
  ;;                 :empty-lines-before 1
  ;;                 :empty-lines-after 1)
  ;;
  ;;org-capture-templates))
  ;;

#+END_SRC

#+RESULTS:

When I'm starting an org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC
** Encryption
#+BEGIN_SRC emacs-lisp
(setq org-crypt-disable-auto-save nil)
(require 'org-crypt)
; Encrypt all entries before saving
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
; GPG key to use for encryption
(setq org-crypt-key "51DE2D88")
#+END_SRC

#+RESULTS:
: 51DE2D88

** Keybinds for org
#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)
#+END_SRC

** Hydras
#+BEGIN_SRC emacs-lisp

(defhydra hydra-global-org (:color blue)
  "Org"
  ("i" org-timer-start "Start Timer")
  ("o" org-timer-stop "Stop Timer")
  ("s" org-timer-set-timer "Set Timer") ; This one requires you be in an orgmode doc, as it sets the timer for the header
  ("p" org-timer "Print Timer") ; output timer value to buffer
  ("w" (org-clock-in '(4)) "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
  ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
  ("j" org-clock-goto "Clock Goto") ; global visit the clocked task
  ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
  ("l" org-capture-goto-last-stored "Last Capture")
  ("r" org-clock-report)
  ("?" (org-info "Clocking commands")))


(global-set-key (kbd "C-c o") 'hydra-global-org/body)


#+END_SRC
** Reveal
#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
:ensure t)
#+END_SRC
#+RESULTS:

** beamer
#+BEGIN_SRC emacs-lisp
(require 'ox-beamer)

#+END_SRC

#+RESULTS:
: ox-beamer

* Flycheck
#+BEGIN_SRC emacs-lisp

(use-package flycheck
:ensure t
:init (global-flycheck-mode))
(use-package flyspell
:ensure t
)

(use-package flyspell-correct-helm
:ensure t
:config 
(progn 
(define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-previous-word-generic)))
(use-package helm-flycheck
:ensure t)


#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
:ensure t)
(use-package helm-projectile
:ensure t
:config 
(helm-projectile-on))


(defhydra hydra-projectile-other-window (:color teal)
  "projectile-other-window"
  ("f"  projectile-find-file-other-window        "file")
  ("g"  projectile-find-file-dwim-other-window   "file dwim")
  ("d"  projectile-find-dir-other-window         "dir")
  ("b"  projectile-switch-to-buffer-other-window "buffer")
  ("q"  nil                                      "cancel" :color blue))

(defhydra hydra-projectile (:color teal
                            :hint nil)
  "
     PROJECTILE: %(projectile-project-root)

     Find File            Search/Tags          Buffers                Cache
------------------------------------------------------------------------------------------
_s-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
 _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
 _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
  _r_: recent file                                               ^^^^_z_: cache current
  _d_: dir

"
  ("a"   projectile-ag)
  ("b"   projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   projectile-find-dir)
  ("s-f" projectile-find-file)
  ("ff"  projectile-find-file-dwim)
  ("fd"  projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("s-p" projectile-switch-project "switch project")
  ("p"   projectile-switch-project)
  ("s"   projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("`"   hydra-projectile-other-window/body "other window")
  ("q"   nil "cancel" :color blue))
(global-set-key (kbd "C-c h p") 'hydra-projectile/body)


#+END_SRC
* Multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
:ensure t)



(defhydra hydra-multiple-cursors (:hint nil)
  "
     ^Up^            ^Down^        ^Other^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
^ ^             ^ ^             [_q_] Quit
"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("r" mc/mark-all-in-region-regexp :exit t)
  ("q" nil))

(global-set-key (kbd "C-c h m") 'hydra-multiple-cursors/body)
#+END_SRC
* Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
:ensure t)

#+END_SRC
* Bind key
#+BEGIN_SRC emacs-lisp
(use-package bind-key
:ensure t)
#+END_SRC
* Writeroom mode
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
:ensure t)

#+END_SRC
* Elpy
#+BEGIN_SRC emacs-lisp
(use-package elpy
:ensure t
:config
(elpy-enable))
#+END_SRC
* Writegood mode
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
:ensure t)
#+END_SRC

* Mail 
#+BEGIN_SRC emacs-lisp
(use-package helm-mu
:ensure t)
#+END_SRC

* Alert
#+BEGIN_SRC emacs-lisp
(use-package alert
  :ensure t
  :config
  (if (executable-find "notify-send")
      (setq alert-default-style 'libnotify)))
#+END_SRC

* Smart parens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :diminish smartparens-mode
  :config
  (progn
    (require 'smartparens-config)
(smartparens-global-mode 1)))
#+END_SRC

* Treemacs
#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :ensure t
  :defer t
  :init
  (with-eval-after-load 'winum
    (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
  :config
  (progn
    (use-package treemacs-evil
      :ensure t
      :demand t)
    (setq treemacs-change-root-without-asking nil
          treemacs-collapse-dirs              (if (executable-find "python") 3 0)
          treemacs-file-event-delay           5000
          treemacs-follow-after-init          t
          treemacs-follow-recenter-distance   0.1
          treemacs-goto-tag-strategy          'refetch-index
          treemacs-indentation                2
          treemacs-indentation-string         " "
          treemacs-is-never-other-window      nil
          treemacs-never-persist              nil
          treemacs-no-png-images              nil
          treemacs-recenter-after-file-follow nil
          treemacs-recenter-after-tag-follow  nil
          treemacs-show-hidden-files          t
          treemacs-silent-filewatch           nil
          treemacs-silent-refresh             nil
          treemacs-sorting                    'alphabetic-desc
          treemacs-tag-follow-cleanup         t
          treemacs-tag-follow-delay           1.5
         ; treemacs-width                      35
)
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (pcase (cons (not (null (executable-find "git")))
                 (not (null (executable-find "python3"))))
      (`(t . t)
       (treemacs-git-mode 'extended))
      (`(t . _)
       (treemacs-git-mode 'simple))))
  :bind
  (:map global-map
        ([f8]         . treemacs-toggle)
        ("M-0"        . treemacs-select-window)))
(use-package treemacs-projectile
  :defer t
  :ensure t
  :config
  (setq treemacs-header-function #'treemacs-projectile-create-header)
  :bind (:map global-map
              ("C-c t P" . treemacs-projectile)
              ))
#+END_SRC
#+RESULTS:

* Evil Mode
#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-want-integration nil)
    :config
    (evil-mode 1))
  (use-package evil-collection
    :after evil
    :ensure t
    :custom (evil-collection-setup-minibuffer t)
    :config
    (setq evil-collection-mode-list 
          `(ace-jump-mode
            ag
            alchemist
            anaconda-mode
            arc-mode
            avy
            bookmark
            (buff-menu "buff-menu")
            calc
            calendar
            cider
            cmake-mode
            comint
            company
            compile
            custom
            cus-theme
            debbugs
            debug
            diff-mode
            dired
            doc-view
            edebug
            elfeed
            elisp-mode
            elisp-refs
            emms
            epa
            eshell
            eval-sexp-fu
            etags-select
            eww
            flycheck
            free-keys
            geiser
            ggtags
            go-mode
            help
            ibuffer
            image
            image+
            indium
            info
            ivy
            js2-mode
            log-view
            lua-mode
            kotlin-mode
            macrostep
            man
           ; ,@(when evil-collection-setup-minibuffer '(minibuffer))
            neotree
            notmuch
            nov
            ;; occur is in replace.el which was built-in before Emacs 26.
            (occur ,(if (<= emacs-major-version 25) "replace" 'replace))
            outline
            p4
            (package-menu package)
            paren
            pass
            popup
            proced
            prodigy
            profiler
            python
            quickrun
            racer
            realgud
            reftex
            rjsx-mode
            robe
            ruby-mode
            rtags
            simple
            slime
            (term term ansi-term multi-term)
            tide
            transmission
            typescript-mode
            vc-annotate
            vdiff
            view
            vlf
            which-key
            woman
            xref
            (ztree ztree-diff))
          )
    (evil-collection-init))
  ;;  (use-package evil-leader
  ;;       :ensure t
  ;;       :config
  ;;       (global-evil-leader-mode))
  ;;  (use-package evil-surround
  ;;       :ensure t
  ;;       :config
  ;;       (global-evil-surround-mode))
  ;;  (use-package evil-indent-textobject
  ;;       :ensure t
  ;; :config
  ;;   (progn
  ;;       (evil-ex-define-cmd "e[dit]" 'helm-find-files)
  ;;       (evil-ex-define-cmd "b[uffer]" 'helm-buffers-list)
  ;;       (bind-key "[escape]" 'keyboard-escape-quit evil-normal-state-map)
  ;;       (bind-key "[escape]" 'keyboard-escape-quit evil-visual-state-map)
  ;; n      (bind-key "<escape>" 'keyboard-escape-quit)))


  (use-package evil-mu4e
    :ensure t)
#+END_SRC
* Ranger
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :ensure t)

#+END_SRC
* Highlights
#+BEGIN_SRC emacs-lisp
(use-package evil-goggles
  :ensure t
  :config
  (evil-goggles-mode)
  ;; optionally use diff-mode's faces; as a result, deleted text
  ;; will be highlighed with `diff-removed` face which is typically
  ;; some red color (as defined by the color theme)
  ;; other faces such as `diff-added` will be used for other actions
  (evil-goggles-use-diff-faces))
(use-package volatile-highlights
:ensure t  
:config
  (volatile-highlights-mode t))
#+END_SRC

* Move text
#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t
  :bind
  (([(meta shift up)] . move-text-up)
   ([(meta shift down)] . move-text-down)))
#+END_SRC

* Line numbers
#+BEGIN_SRC emacs-lisp
  (use-package linum
    :ensure t)
#+END_SRC

* wgrep
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t)

#+END_SRC
* Undo tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
:ensure t
:init
(global-undo-tree-mode))
#+END_SRC

* Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper-helm
:ensure t
:config 
(progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-s" 'swiper)
))
#+END_SRC

* Ledger mode
#+BEGIN_SRC emacs-lisp
   (use-package ledger-mode
     :ensure t
     :init
     (setq ledger-clear-whole-transactions 1)
     :mode ("\\.ledger$" . ledger-mode)
   :init
   (defvar my/ledger-file
     (expand-file-name "~/Orgs/Finances/")
     "Where the ledger journal is kept.")
   (setq file-ledger "finances.ledger")
     :config
     (add-to-list 'evil-emacs-state-modes 'ledger-report-mode)
   (setq ledger-post-amount-alignment-column 70)
    (setq ledger-post-amount-alignment-at :decimal)
    ;; There is a correct way to write dates:
    ;; https://xkcd.com/1179/
    (setq ledger-use-iso-dates t)
  (setq ledger-reports '(("on-hand" "ledger -f %(ledger-file) --color bal \"(Assets:Checking|Savings|Liabilities)\"")
                         ("bal" "ledger -f %(ledger-file) --color bal")
                         ("reg" "ledger -f %(ledger-file) --color reg")
                         ("payee" "ledger -f %(ledger-file) --color  reg @%(payee)")
                         ("account" "ledger -f %(ledger-file) --color reg %(account)")
                         ("budgeted" "ledger --unbudgeted --monthly register ^expenses -f %(ledger-file)")
                         ("unbudgeted" "ledger --budgeted --monthly register ^expenses -f %(ledger-file)") )))
   (use-package flycheck-ledger
     :ensure t
     :init
     :mode "\\.ledger$'")


(use-package evil-ledger
  :ensure t
  :after ledger-mode
  :config
  (setq evil-ledger-sort-key "S")
  (add-hook 'ledger-mode-hook #'evil-ledger-mode))
#+END_SRC

* Windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  ;; :defer 4
  :ensure t
  :config
 (global-set-key (kbd "C-c <left>")  'windmove-left)
 (global-set-key (kbd "C-c <right>") 'windmove-right)
 (global-set-key (kbd "C-c <up>")    'windmove-up)
 (global-set-key (kbd "C-c <down>")  'windmove-down)
  ;; wrap around at edges
  (setq windmove-wrap-around t))
#+END_SRC
#+RESULTS:
: t
* Google translate
#+BEGIN_SRC emacs-lisp
(use-package google-translate
  :ensure t
  :bind
  (:map mu4e-view-mode-map
        ("C-c t" . google-translate-at-point))
  :config
  (setq google-translate-default-target-language "English")
  ;; It won't ask for the input language. If I need it to, call the
  ;; translation command with a C-u prefix:
  (setq google-translate-default-source-language "Swedish"))
#+END_SRC

* CSV files
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :ensure t
  :mode (("\\.csv" . csv-mode)))
#+END_SRC

* Gitgutter
#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :ensure t
  :init
  (global-git-gutter-mode)
  :config
(setq git-gutter-fr:side 'left-fringe)
;(setq git-gutter-modified-sign "¤")
(setq-default left-fringe-width  20)
(setq-default right-fringe-width 20)
)
(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                            :hint nil)
  "
Git gutter:
  _j_: next hunk        _s_tage hunk     _q_uit
  _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
  ^ ^                   _p_opup hunk
  _h_: first hunk
  _l_: last hunk        set start _R_evision
"
  ("j" git-gutter:next-hunk)
  ("k" git-gutter:previous-hunk)
  ("h" (progn (goto-char (point-min))
              (git-gutter:next-hunk 1)))
  ("l" (progn (goto-char (point-min))
              (git-gutter:previous-hunk 1)))
  ("s" git-gutter:stage-hunk)
  ("r" git-gutter:revert-hunk)
  ("p" git-gutter:popup-hunk)
  ("R" git-gutter:set-start-revision)
  ("q" nil :color blue)
  ("Q" (progn (git-gutter-mode -1)
              ;; git-gutter-fringe doesn't seem to
              ;; clear the markup right away
              (sit-for 0.1)
              (git-gutter:clear))
       :color blue))
(global-set-key (kbd "C-c h g") 'hydra-git-gutter/body)
#+END_SRC

#+RESULTS:
: hydra-git-gutter/body

* Restart emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
:ensure t)
#+END_SRC
#+RESULTS:

* Org-toc
#+BEGIN_SRC emacs-lisp
(use-package toc-org
:ensure t)
(add-hook 'org-mode-hook 'toc-org-enable)
#+END_SRC
#+RESULTS:

* Haskell
#+BEGIN_SRC emacs-lisp
(use-package dante
  :ensure t
  :after haskell-mode
  :commands 'dante-mode
  :init
  (add-hook 'haskell-mode-hook 'dante-mode)
  (add-hook 'haskell-mode-hook 'flycheck-mode))

#+END_SRC
* Scala setup
** Ensime
#+BEGIN_SRC emacs-lisp
(use-package ensime
:ensure t
:bind ("C-c C-c c" . ensime)
:config
(progn (setq ensime-sem-high-faces
        '( (implicitConversion nil)
           (var . (:foreground "#ff2222"))
           (val . (:foreground "#dddddd"))
           (varField . (:foreground "#ff3333"))
           (valField . (:foreground "#dddddd"))
           (functionCall . (:foreground "#dc9157"))
           (param . (:foreground "#ffffff"))
           (object . (:foreground "#D884E3"))
           (class . (:foreground "green"))
           (trait . (:foreground "#009933"))
           (operator . (:foreground "#cc7832"))
           (object . (:foreground "#6897bb" :slant italic))
           (package . (:foreground "yellow"))
           (implicitConversion . (:underline (:style wave :color "blue")))
           (implicitParams . (:underline (:style wave :color "blue")))
           (deprecated . (:strike-through "#a9b7c6"))
           (implicitParams nil)
         )
        ensime-completion-style 'company
        ensime-sem-high-enabled-p nil ;; disable semantic highlighting
        ensime-tooltip-hints t ;; disable type-inspecting tooltips
        ensime-tooltip-type-hints t ;; disable typeinspecting tooltips
)
    (global-set-key (kbd "C-c C-c c") 'ensime)
))
#+END_SRC
#+RESULTS:
** Turn them on
#+BEGIN_SRC emacs-lisp
(add-hook 'scala-mode-hook
          (lambda ()
            (show-paren-mode)
            (smartparens-mode)
            (yas-minor-mode)
            (git-gutter-mode)
            (company-mode)
            (ensime-mode)
            (scala-mode:goto-start-of-code)))
#+END_SRC
** New line in comments
#+BEGIN_SRC emacs-lisp
(defun scala-mode-newline-comments ()
  "Custom newline appropriate for `scala-mode'."
  ;; shouldn't this be in a post-insert hook?
  (interactive)
  (newline-and-indent)
  (scala-indent:insert-asterisk-on-multiline-comment))
;(bind-key "RET" 'scala-mode-newline-comments scala-mode-map)
(setq comment-start "/* "
          comment-end " */"
          comment-style 'multi-line
          comment-empty-lines t)
#+END_SRC
* Company mode
#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path "/usr/local/bin")
(use-package company
  :ensure t
  :bind
  (:map company-active-map
        ("C-s" . company-search-candidates)
        ("<tab>" . company-complete-common-or-cycle)
        ("RET" . company-complete-selection)
        ("C-n" . company-select-next)
        ("C-p" . company-select-previous))
  :init
  (add-hook 'after-init-hook #'global-company-mode)
  :config
  (setq company-minimum-prefix-length 2)
  (setq company-idle-delay 0.5)
  (setq company-require-match nil)
  (use-package company-statistics
    :ensure t
    :config
    (setq company-statistics-file
          (concat my/emacs-cache "company-statistics-cache.el"))
    (add-hook 'company-mode-hook #'company-statistics-mode))
  (use-package company-math
    :ensure t
    :config
    (add-to-list 'company-backends 'company-math-symbols-latex))
  (use-package company-quickhelp
    :ensure t
    :config
    (company-quickhelp-mode))
  (use-package company-flx
    :ensure t
    :init
    (with-eval-after-load 'company
      (company-flx-mode +1)))
  (use-package company-web-html
    :ensure company-web)
  (use-package company-shell
    :ensure t
    :config
    (add-to-list 'company-backends 'company-shell)))
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC
* Python
#+BEGIN_SRC emacs-lisp
(setq py-python-command "python3")
(setq python-shell-interpreter "python3")

  (use-package jedi
    :ensure t
    :init
    (add-hook 'python-mode-hook 'jedi:setup)
    (add-hook 'python-mode-hook 'jedi:ac-setup))


    (use-package elpy
    :ensure t
    :config 
    (elpy-enable))

(use-package virtualenvwrapper
  :ensure t
  :config
  (venv-initialize-interactive-shells)
  (venv-initialize-eshell))
#+END_SRC
#+RESULTS:
* Beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1)
                                          ; (setq beacon-color "#666600")
    )
#+END_SRC
* Writing 
** Latex
#+BEGIN_SRC emacs-lisp
    (use-package auctex-latexmk
    :ensure t
      :config 
      (auctex-latexmk-setup)
      (setq auctex-latexmk-inherit-TeX-PDF-mode t)
  (use-package tex-site
    :ensure auctex
    :mode ("\\.tex\\'" . latex-mode)
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil)
    (add-hook 'LaTeX-mode-hook
              (lambda ()
                (rainbow-delimiters-mode)
                (company-mode)
                (smartparens-mode)
                (turn-on-reftex)
                (setq reftex-plug-into-AUCTeX t)
                (reftex-isearch-minor-mode)
                (flyspell-mode)
                (visual-line-mode)
                (setq TeX-PDF-mode t)
                (setq TeX-source-correlate-method 'synctex)
                (setq TeX-source-correlate-start-server t)))
  ;; Update PDF buffers after successful LaTeX runs
  (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
             #'TeX-revert-document-buffer)
  ;; to use pdfview with auctex
  (add-hook 'LaTeX-mode-hook 'pdf-tools-install)
  ;; to use pdfview with auctex
  (setq TeX-view-program-selection '((output-pdf "pdf-tools"))
         TeX-source-correlate-start-server t)
  (setq TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view"))))
)
    (use-package latex-preview-pane
    :ensure t)
(use-package reftex
  :ensure t
  :defer t
  :config
  (setq reftex-cite-prompt-optional-args t)); Prompt for empty optional arguments in cite
#+END_SRC
#+RESULTS:
** Wrap paragraphs automatically
I dont like =AutoFillMode= which  automatically wraps paragraphs, kinda
like hitting =M-q=. But i like wrapped paragraphs, hence use visual fill
mode

#+BEGIN_SRC emacs-lisp
      (add-hook 'LaTeX-mode-hook 'visual-line-mode)
      (add-hook 'text-mode-hook 'visual-line-mode)
      (add-hook 'org-mode-hook 'visual-line-mode)

    (use-package visual-fill-column
      :ensure t
      :config
  (add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
  (advice-add 'text-scale-adjust :after
    #'visual-fill-column-adjust)
  (setq visual-fill-column-width 100)
  (setq-default fill-column 100)
   (setq visual-fill-column-center-text t)
   )
#+END_SRC
#+RESULTS:
: t


** Syntex with evince
#+BEGIN_SRC emacs-lisp
(require 'dbus)
(defun un-urlify (fname-or-url)
  "A trivial function that replaces a prefix of file:/// with just /."
  (if (string= (substring fname-or-url 0 8) "file:///")
     (substring fname-or-url 7)
    fname-or-url))
(defun th-evince-sync (file linecol &rest ignored)
  (let* ((fname (un-urlify file))
         (buf (find-buffer-visiting fname))
         (line (car linecol))
         (col (cadr linecol)))
    (if (null buf)
        (message "[Synctex]: %s is not opened..." fname)
      (switch-to-buffer buf)
      (goto-line (car linecol))
      (unless (= col -1)
        (move-to-column col)))))
(defvar *dbus-evince-signal* nil)
(defun enable-evince-sync ()
  (require 'dbus)
  (when (and
         (eq window-system 'x)
         (fboundp 'dbus-register-signal))
    (unless *dbus-evince-signal*
      (setf *dbus-evince-signal*
            (dbus-register-signal
             :session nil "/org/gnome/evince/Window/0"
             "org.gnome.evince.Window" "SyncSource"
             'th-evince-sync)))))
(add-hook 'LaTeX-mode-hook 'enable-evince-sync)
#+END_SRC
#+RESULTS:
| enable-evince-sync | visual-line-mode | pdf-tools-install | (lambda nil (rainbow-delimiters-mode) (company-mode) (smartparens-mode) (turn-on-reftex) (setq reftex-plug-into-AUCTeX t) (reftex-isearch-minor-mode) (flyspell-mode) (visual-line-mode) (setq TeX-PDF-mode t) (setq TeX-source-correlate-method (quote synctex)) (setq TeX-source-correlate-start-server t)) | (lambda nil (flyspell-mode)) | (lambda nil (writegood-mode)) | dubcaps-mode |
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "markdown"))
#+END_SRC
#+RESULTS:
** lang tool
#+BEGIN_SRC emacs-lisp
(use-package langtool
:ensure t
:config 
(setq langtool-language-tool-jar "~/.emacs.d/vendor/langtool/languagetool-commandline.jar")
(setq langtool-default-language "en-US")
(setq langtool-java-classpath nil))  
#+END_SRC
#+RESULTS:
: t
** Synonyms
#+BEGIN_SRC emacs-lisp
(use-package synosaurus
:ensure t
:config
(setq synosaurus-choose-method 'popup))
#+END_SRC
#+RESULTS:
: t
** Dictionary
#+BEGIN_SRC emacs-lisp
(use-package helm-dictionary
:ensure t)
#+END_SRC
#+RESULTS:
* Bibliotek
#+BEGIN_SRC emacs-lisp
  (use-package bibliothek
    :ensure t
    :config
    (setq bibliothek-path (list "~/readingMaterial"))
    )

#+END_SRC
* Mail setup
#+BEGIN_SRC emacs-lisp
(use-package helm-mu
:ensure t
:config
(progn
  (require 'mu4e)
  (require 'mu4e-contrib)
  (require 'helm-mu)
  (require 'org-mu4e)
 (global-set-key (kbd "<f2>") 'mu4e)
 (setq mu4e-maildir "~/mail")
    (setq mu4e-drafts-folder "/Drafts")
    (setq mu4e-sent-folder   "/Sent")
    (setq mu4e-trash-folder  "/Trash")
      (setq mu4e-compose-signature-auto-include t)
  (setq mu4e-compose-format-flowed t)
(setq mu4e-change-filenames-when-moving t)
    ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
    (setq mu4e-sent-messages-behavior 'sent)
    ;; setup some handy shortcuts
    ;; you can quickly switch to your Inbox -- press ``ji''
    ;; then, when you want archive some messages, move them to
    ;; the 'All Mail' folder by pressing ``ma''.
    (setq mu4e-maildir-shortcuts
          '( ("/Inbox"               . ?i)
             ("/Sent"   . ?s)
             ("/Drafts" . ?d)
             ("/Trash"       . ?t)
             ("/All Mail"    . ?a)))
    ;; allow for updating mail using 'U' in the main view:
    (setq mu4e-update-interval 600)
    (setq mu4e-get-mail-command "mbsync chalmers")
    ;; something about ourselves
    (setq
     user-mail-address "ashfaqf@chalmers.se"
     user-full-name  "Ashfaq Farooqui"
     message-signature  (concat "\n"
      "//Ashfaq"
      "\n"))
    (setq mu4e-compose-signature t)
    ;; sending mail -- replace USERNAME with your gmail username
    ;; also, make sure the gnutls command line utils are installed
    ;; package 'gnutls-bin' in Debian/Ubuntu
    (require 'smtpmail)
    (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-auth-credentials
      (expand-file-name "~/.emacs.d/.authinfo.gpg")
        smtpmail-default-smtp-server "localhost"
        smtpmail-smtp-server "localhost"
        smtpmail-smtp-service 1025)
    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t)
    ;;store org-mode links to messages
    ;;store link to message if in header view, not to header query
    (setq org-mu4e-link-query-in-headers-mode nil)
(setq
       ;; mu4e-use-fancy-chars t
       ;; mu4e-view-prefer-html t
       org-mu4e-convert-to-html t
       mu4e-show-images t
       mu4e-headers-include-related nil
       mu4e-headers-skip-duplicates t
mu4e-headers-visible-lines 18)
    ;;; Html rendering
    (setq mu4e-view-prefer-html t)
    (setq mu4e-use-fancy-chars t)
    (setq mu4e-attachment-dir "~/Documents/mail")
    ;;; Attempt to show images when viewing messages
    (setq mu4e-view-show-images t
          mu4e-view-image-max-width 800)
    ;; View html message in firefox (type aV)
    (add-to-list 'mu4e-view-actions
                '("ViewInBrowser" . mu4e-action-view-in-browser) t)
  ;; PGP-Sign all e-mails
  (add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)
))
#+END_SRC
* Academic phrases
#+BEGIN_SRC emacs-lisp
  (use-package academic-phrases 
    :ensure t)

#+END_SRC
* Speed typing
#+BEGIN_SRC emacs-lisp
  (use-package speed-type
    :ensure t)
#+END_SRC
* Theme
#+BEGIN_SRC emacs-lisp
                                          ;(use-package zenburn-theme
                                          ;:ensure t
                                          ;:config
                                          ;(load-theme 'zenburn t))
  (use-package zerodark-theme
    :ensure t
    :config
    (load-theme 'zerodark t)
    (zerodark-setup-modeline-format))
  ;;  (use-package powerline
  ;;  :ensure t
  ;;  :config
  ;;  (powerline-center-evil-theme))
  ;;    (use-package spacemacs-common
  ;;      :ensure spacemacs-theme
  ;;      :init
  ;;      (load-theme 'spacemacs-dark t)
  ;;      (setq spacemacs-theme-org-agenda-height nil)
  ;;      (setq spacemacs-theme-org-height nil))
  ;;    (set-face-attribute 'org-level-1 nil :height 1.0)
  ;;    (set-face-attribute 'org-level-2 nil :height 1.0)
  ;;    (set-face-attribute 'org-level-3 nil :height 1.0)
  ;;    (set-face-attribute 'org-scheduled-today nil :height 1.0)
  ;;    (set-face-attribute 'org-agenda-date-today nil :height 1.1)
  ;;    (set-face-attribute 'org-table nil :foreground "#008787")
  ;;  (use-package spaceline
  ;;    :ensure t
  ;;    :config
  ;;    (require 'spaceline-config)
  ;;    (spaceline-emacs-theme)
  ;;    (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state))
(if (daemonp)
    (add-hook 'after-make-frame-functions
        (lambda (frame)
            (with-selected-frame frame
                (load-theme 'zerodark t))))
    (load-theme 'zerodark t))
#+END_SRC
* Loading complete
#+BEGIN_SRC emacs-lisp
(alert "Emacs has started")
#+END_SRC
#+RESULTS:

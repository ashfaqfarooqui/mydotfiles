# -*- mode: org; coding: utf-8; -*-
#+TITLE: Ashfaq Farooqui's Emacs Configuration
#+AUTHOR: Ashfaq Farooqui
#+EMAIL: ashfaq@ashfaqfarooqui.me
#+OPTIONS: toc:3 num:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
#+Startup: content


* User Details
#+begin_src emacs-lisp
     (setq user-full-name "Ashfaq Farooqui")
     (setq user-mail-address "ashfaq@ashfaqfarooqui.me")
#+end_src
* Basics
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)                         ; Replace selection when inserting text
(display-time-mode 1)                             ; Enable time in the mode-line
(display-battery-mode 1)                          ; On laptops it's nice to know how much power you have
(global-subword-mode 1)                           ; Iterate through CamelCase words
(setq initial-major-mode 'org-mode)
(setq hungry-delete-mode t)
(show-smartparens-mode)
#+END_SRC

** Initialize personal keymap
#+begin_src emacs-lisp
(define-prefix-command 'z-map)
(global-set-key (kbd "C-z") 'z-map) ;; was C-1

#+end_src
#+RESULTS:
: org-mode


* Visual  configuration
** Fonts
#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Mononoki Nerd Font" :size 24)
      doom-big-font (font-spec :family "Mononoki Nerd Font" :size 36))

#+END_SRC

#+RESULTS:
: #<font-spec nil nil sans nil nil nil nil nil 13 nil nil nil nil>
** Rainbow mode
#+BEGIN_SRC emacs-lisp
(use-package! rainbow-mode
  :after rainbow-delimiter
:init (rainbow-mode))

(after! rainbow-delimiters
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
(add-hook 'text-mode-hook #'rainbow-delimiters-mode)
(add-hook 'org-mode-hook #'rainbow-delimiters-mode)
)

#+END_SRC

** nyan mode
#+BEGIN_SRC emacs-lisp
    (after! nyan-mode
         :init
        (nyan-mode))


#+END_SRC
** Heaven and hell

#+begin_src emacs-lisp
(after! heaven-and-hell
  :init
  (setq heaven-and-hell-theme-type 'dark) ;; Omit to use light by default
  (setq heaven-and-hell-themes
        '((light . doom-solarized-light)
          (dark . doom-one))) ;; Themes can be the list: (dark . (tsdh-dark wombat))
  ;; Optionall, load themes without asking for confirmation.
  (setq heaven-and-hell-load-theme-no-confirm t)
  :hook (after-init . heaven-and-hell-init-hook)
  :bind (("C-c <f6>" . heaven-and-hell-load-default-theme)
         ("<f6>" . heaven-and-hell-toggle-theme)))

#+end_src

#+RESULTS:
: heaven-and-hell-toggle-theme
* Stuff
** elfeed

#+BEGIN_SRC emacs-lisp

(setq elfeed-db-directory "~/Documents/.elfeed")
(setq rmh-elfeed-org-files (list "~/.doom.d/elfeed.org"))
#+END_SRC
*** TODO Elfeed vidio and podcasts
** Ibuffer
#+BEGIN_SRC emacs-lisp
  (after! ibuffer
    (progn (setq ibuffer-saved-filter-groups
                 (quote (("default"
                          ("dired" (mode . dired-mode))
                          ("org" (name . "^.*org$"))
                          ("web" (or (mode . web-mode) (mode . js2-mode)))
                          ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
                          ("latex" (or (mode . latex-mode)
                                       (name . "^.*tex$")
                                       (filename . "ShareLaTeX") ))
                          ("mu4e" (or
                                   (mode . mu4e-compose-mode)
                                   (name . "\*mu4e\*")
                                   ))
                          ("programming" (or
                                          (mode . python-mode)
                                          (mode . c++-mode)
                                          (mode . scala-mode)
                                          (mode . haskell-mode)))
                          ("Magit" (name . "\\*magit\\*"))
                          ("emacs-config" (or (filename . ".doom.d")
                                              (filename . "emacs-config")))

                          ("emacs" (or
                                    (name . "^\\*scratch\\*$")
                                    (name . "^\\*Messages\\*$")))
                          ))))
           (add-hook 'ibuffer-mode-hook
                     (lambda ()
                       (ibuffer-auto-mode 1)
                       (ibuffer-switch-to-saved-filter-groups "default"))))
    (setq ibuffer-show-empty-filter-groups nil)

    )
    (defalias 'list-buffers 'ibuffer-other-window)

#+END_SRC


*** hydra ibuf
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-ibuffer-main (:color pink :hint nil)
    "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
    _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
    ("j" ibuffer-forward-line)
    ("RET" ibuffer-visit-buffer :color blue)
    ("k" ibuffer-backward-line)

    ("m" ibuffer-mark-forward)
    ("u" ibuffer-unmark-forward)
    ("*" hydra-ibuffer-mark/body :color blue)

    ("D" ibuffer-do-delete)
    ("S" ibuffer-do-save)
    ("a" hydra-ibuffer-action/body :color blue)

    ("g" ibuffer-update)
    ("s" hydra-ibuffer-sort/body :color blue)
    ("/" hydra-ibuffer-filter/body :color blue)

    ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
    ("q" quit-window "quit ibuffer" :color blue)
    ("." nil "toggle hydra" :color blue))

  (defhydra hydra-ibuffer-mark (:color teal :columns 5
                                :after-exit (hydra-ibuffer-main/body))
    "Mark"
    ("*" ibuffer-unmark-all "unmark all")
    ("M" ibuffer-mark-by-mode "mode")
    ("m" ibuffer-mark-modified-buffers "modified")
    ("u" ibuffer-mark-unsaved-buffers "unsaved")
    ("s" ibuffer-mark-special-buffers "special")
    ("r" ibuffer-mark-read-only-buffers "read-only")
    ("/" ibuffer-mark-dired-buffers "dired")
    ("e" ibuffer-mark-dissociated-buffers "dissociated")
    ("h" ibuffer-mark-help-buffers "help")
    ("z" ibuffer-mark-compressed-file-buffers "compressed")
    ("b" hydra-ibuffer-main/body "back" :color blue))

  (defhydra hydra-ibuffer-action (:color teal :columns 4
                                  :after-exit
                                  (if (eq major-mode 'ibuffer-mode)
                                      (hydra-ibuffer-main/body)))
    "Action"
    ("A" ibuffer-do-view "view")
    ("E" ibuffer-do-eval "eval")
    ("F" ibuffer-do-shell-command-file "shell-command-file")
    ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
    ("H" ibuffer-do-view-other-frame "view-other-frame")
    ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
    ("M" ibuffer-do-toggle-modified "toggle-modified")
    ("O" ibuffer-do-occur "occur")
    ("P" ibuffer-do-print "print")
    ("Q" ibuffer-do-query-replace "query-replace")
    ("R" ibuffer-do-rename-uniquely "rename-uniquely")
    ("T" ibuffer-do-toggle-read-only "toggle-read-only")
    ("U" ibuffer-do-replace-regexp "replace-regexp")
    ("V" ibuffer-do-revert "revert")
    ("W" ibuffer-do-view-and-eval "view-and-eval")
    ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
    ("b" nil "back"))

  (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
    "Sort"
    ("i" ibuffer-invert-sorting "invert")
    ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
    ("v" ibuffer-do-sort-by-recency "recently used")
    ("s" ibuffer-do-sort-by-size "size")
    ("f" ibuffer-do-sort-by-filename/process "filename")
    ("m" ibuffer-do-sort-by-major-mode "mode")
    ("b" hydra-ibuffer-main/body "back" :color blue))

  (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
    "Filter"
    ("m" ibuffer-filter-by-used-mode "mode")
    ("M" ibuffer-filter-by-derived-mode "derived mode")
    ("n" ibuffer-filter-by-name "name")
    ("c" ibuffer-filter-by-content "content")
    ("e" ibuffer-filter-by-predicate "predicate")
    ("f" ibuffer-filter-by-filename "filename")
    (">" ibuffer-filter-by-size-gt "size")
    ("<" ibuffer-filter-by-size-lt "size")
    ("/" ibuffer-filter-disable "disable")
    ("b" hydra-ibuffer-main/body "back" :color blue))


  (define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)
(add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
#+END_SRC

** Supersave
#+begin_src emacs-lisp
(after! super-save
(super-save-mode +1))
(setq super-save-exclude '(".gpg"))
(setq super-save-auto-save-when-idle t)
#+END_SRC
** TODO COMMENT Swiper, avy, counsel
Look at what we need from here. its mainly the key bindings I require for swiper and avy.
#+BEGIN_SRC emacs-lisp


(setq counsel-grep-base-command
      "rg -i -M 120 --no-heading --line-number --color never %s %s")


  (after! avy
    :bind
    (
     ("M-j" . 'avy-goto-word-1)
     ("C-j" . 'avy-goto-char-2)
     ("C-S-j" . 'avy-goto-line)
     )
    )

  (setq avy-timeout-seconds 2.0)


  (after! swiper
    :bind (("C-s" . swiper-isearch)
           ("C-r" . swiper)
           ("C-c C-r" . ivy-resume)
           ("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file))
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (setq enable-recursive-minibuffers t)
      (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
      ))
#+END_SRC

** Multiple cursors
Hydra for MC
#+BEGIN_SRC emacs-lisp


(defhydra hydra-multiple-cursors (:hint nil)
  "
     ^Up^            ^Down^        ^Other^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
^ ^             ^ ^             [_q_] Quit
"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("r" mc/mark-all-in-region-regexp :exit t)
  ("q" nil))



#+END_SRC
** Alert
#+BEGIN_SRC emacs-lisp
(after! alert
  :config
  (if (executable-find "notify-send")
      (setq alert-default-style 'libnotify)))
#+END_SRC
** Undo tree
#+BEGIN_SRC emacs-lisp
(after! undo-tree
  :init
  (global-undo-tree-mode)
  :config
  (setq undo-tree-auto-save-history t)

  ;; Compress the history files as .gz files
  (advice-add 'undo-tree-make-history-save-file-name :filter-return
              (lambda (return-val) (concat return-val ".gz")))

  ;; Persistent undo-tree history across emacs sessions
  (setq af/undo-tree-history-dir (let ((dir (concat user-emacs-directory
                                                    "undo-tree-history/")))
                                   (make-directory dir :parents)
                                   dir))
  (setq undo-tree-history-directory-alist `(("." . ,af/undo-tree-history-dir)))
  )
#+END_SRC

#+RESULTS:
: t

** Ledger mode
#+BEGIN_SRC emacs-lisp
   (after! ledger-mode
    :init
     (setq ledger-clear-whole-transactions 1)
     :mode ("\\.ledger$" . ledger-mode)
   :init
   (defvar my/ledger-file
     (expand-file-name "~/Orgs/Finances/")
     "Where the ledger journal is kept.")
   (setq file-ledger "finances.ledger")
     :config
   (setq ledger-post-amount-alignment-column 70)
    (setq ledger-post-amount-alignment-at :decimal)
    ;; There is a correct way to write dates:
    ;; https://xkcd.com/1179/
    (setq ledger-use-iso-dates t)
  (setq ledger-reports '(("on-hand" "ledger -f %(ledger-file) --color bal \"(Assets:Checking|Savings|Liabilities)\"")
                         ("bal" "ledger -f %(ledger-file) --color bal")
                         ("reg" "ledger -f %(ledger-file) --color reg")
                         ("payee" "ledger -f %(ledger-file) --color  reg @%(payee)")
                         ("account" "ledger -f %(ledger-file) --color reg %(account)")
                         ("budgeted" "ledger --unbudgeted --monthly register ^expenses -f %(ledger-file)")
                         ("unbudgeted" "ledger --budgeted --monthly register ^expenses -f %(ledger-file)") )))
   (use-package! flycheck-ledger
         :mode "\\.ledger$'")


#+END_SRC
** Aggressive indent
#+begin_src emacs-lisp
(after! aggressive-indent
  :hook ((css-mode . aggressive-indent-mode)
         (emacs-lisp-mode . aggressive-indent-mode)
         (js-mode . aggressive-indent-mode)
         (lisp-mode . aggressive-indent-mode))
  :custom (aggressive-indent-comments-too))

#+end_src

#+RESULTS:
| aggressive-indent-mode |
** Wrap paragraphs automatically
I dont like =AutoFillMode= which  automatically wraps paragraphs, kinda
like hitting =M-q=. But i like wrapped paragraphs, hence use visual fill
mode

#+BEGIN_SRC emacs-lisp
      (add-hook 'LaTeX-mode-hook 'visual-line-mode)
      (add-hook 'text-mode-hook 'visual-line-mode)
      (add-hook 'org-mode-hook 'visual-line-mode)

    (use-package visual-fill-column
      :ensure t
      :config
  (add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
  (advice-add 'text-scale-adjust :after
    #'visual-fill-column-adjust)
  (setq visual-fill-column-width 100)
  (setq-default fill-column 100)
   (setq visual-fill-column-center-text t)
   )
#+END_SRC
#+RESULTS:
: t

* OrgMode
** org habit
#+BEGIN_SRC emacs-lisp
(after! org
(add-to-list 'org-modules 'org-habit t)
; position the habit graph on the agenda to the right of the default
(setq org-habit-graph-column 50)

(require 'org-habit)
(setq org-habit-following-days 7)
(setq org-habit-preceding-days 35)
(setq org-habit-show-habits t)
)



#+END_SRC

** Directory setup
Store my org files in =~/Orgs=, define an index file and an
archive of finished tasks in =archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Orgs")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file
        (concat (org-file-path "inbox-orgzly.org")))
  (setq org-personal-file (org-file-path "personal.org"))
  (setq org-index-file (org-file-path "index.org"))
  (setq org-phd-file (concat (org-file-path "PHD/Phd.org")))
(setq org-basb-main-file (concat (org-file-path "BASB/main.org")))


#+END_SRC
** COMMENT Sequences
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords '((sequence
                             "TODO(t)"  ; next action
                             "NEXT(n)"
                             "WAITING(w@/!)"
                             "SOMEDAY(.)" "MAYBE(m)" "|" "DONE(x!)" "CANCELLED(c@)")
                            (sequence "IDEA"))
)

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "#cc6666" :weight bold)
                ("NEXT" :foreground "#8abeb7" :weight bold)
                ("DONE" :foreground "#b5bd68" :weight bold)
                ("WAITING" :foreground "#de935f" :weight bold)
                ("MAYBE" . (:foreground "#b394aa" :weight book))
                ("SOMEDAY" :foreground "#b294bb" :weight bold)
                ("CANCELLED" :foreground "#f0c674" :weight bold))))

  (setq org-log-done t)

#+END_SRC

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
            (lambda ()
              (org-bullets-mode t)))
#+END_SRC

#+RESULTS:

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC


some more misc settings
#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities          t ; UTF8 all the things!
      org-support-shift-select     t ; holding shift and moving point should select things
      org-M-RET-may-split-line     nil ; M-RET may never split a line
      org-enforce-todo-dependencies t ; can't finish parent before children
      org-enforce-todo-checkbox-dependencies t ; can't finish parent before children
      org-hide-emphasis-markers t ; make words italic or bold, hide / and *
      org-catch-invisible-edits 'error ; don't let me edit things I can't see
      org-startup-indented t) ; start with indentation setup
(setq org-startup-with-inline-images t) ; show inline images
(setq org-log-done t)
(setq org-goto-interface (quote outline-path-completion))
(use-package htmlize
  :ensure t)
(setq org-special-ctrl-a/e t)
#+END_SRC
** Org-tags
#+BEGIN_SRC emacs-lisp
; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            ("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?H)
                            (:endgroup)
                      ("Challenge" . ?1)
                      ("Average" . ?2)
                      ("Easy" . ?3)
                            ("crypt" . ?E)
                            ("NOTE" . ?n)
)))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)

#+END_SRC

#+RESULTS:
: t
** org-agenda
Use all the files to derive agenda.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file org-inbox-file org-basb-main-file))
                                          ;   (setq org-agenda-include-diary t)
                                          ;   (setq org-agenda-include-all-todo t)
  (setq org-habit-show-habits-only-for-today t)


  ;; Do not dim blocked tasks
  (setq org-agenda-dim-blocked-tasks nil)

  ;; Compact the block agenda view
  (setq org-agenda-compact-blocks t)




  (use-package org-super-agenda
    :ensure t
    :config
    (org-super-agenda-mode t)
    (setq org-super-agenda-groups
          '(
            (:name "Today\n"
                   :time-grid t
                   :and(:scheduled today :not (:habit t))
                   )
            (:name "Important"
                   :priority "A")
            (:name "Overdue"
                   :deadline past)
            (:name "Habits\n"
                   :habit t)
            (:name "To Scheduled\n"
                   :scheduled nil)
            )  ;; end setq superagenda block
          )) ;; end whole super agenda block


  (add-to-list 'org-agenda-custom-commands
               '("u" "Unscheduled TODOs"
                 ((todo ""
                        ((org-agenda-overriding-header "\nUnscheduled TODO")
                         (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'todo '("DONE" "CANCELLED" "MAYBE" "WAITING" "SOMEDAY"))))))) t)

#+END_SRC

#+RESULTS:
| n | Agenda and all TODOs | ((agenda ) (alltodo ))                 |
| u | Unscheduled TODOs    | ((todo  ((org-agenda-overriding-header |
** Capturing

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =blog-ideas.org=,
- Record everything related to Phd stuff in =~/Phd Notebook.org=, and
- Maintain a todo list in =to-do.org=.
- Maintain a reading list in =to-read.org=

#+BEGIN_SRC emacs-lisp
      (setq org-capture-templates
            (quote (

                    ("p" "Protocol" entry (file+headline org-index-file "Links")
                     "* %^{Title}\nCaptured On: %U\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
                    ("L" "Protocol Link" entry (file+headline org-index-file "Links")
                     "* %? [[%:link][%:description]] \nCaptured On: %U")

                    ("P" "Project" entry (file+headline org-basb-main-file "Projects")
                     (file "~/.doom.d/templates/newProjecttemplate.org") :empty-lines 1)

                    ("s" "Someday" entry (file+headline "~/Orgs/BASB/somedaymaybe.org" "Someday / Maybe")
                     "* SOMEDAY %?\n")
                    ("m" "Maybe" entry (file+headline "~/Orgs/BASB/somedaymaybe.org" "Someday / Maybe")
                     "* MAYBE %?\n")


                    ("n" "Notes"
                     entry
                     (file+headline org-index-file "Notes")
                     "* %u %? :NOTE:\n")

                    ("t" "Task"
                     entry
                     (file+headline org-index-file "Tasks")
                     "* TODO %?\n")

                     ("h" "health log")
                    ("hr" "Running" entry (file+headline  "~/Orgs/BASB/Areas/Health/log.org" "Running")
                     (file "~/.doom.d/templates/running.org") :empty-lines 1)

                    ("hs" "Sleep" entry (file+headline  "~/Orgs/BASB/Areas/Health/log.org" "Sleep")
                     (file "~/.doom.d/templates/sleep.org") :empty-lines 1)


                    ("e" "Email" entry (file+headline org-index-file "Mail")
                     "* TODO %? email |- %:from: %:subject :EMAIL:\n:PROPERTIES:\n:CREATED: %U\n:EMAIL-SOURCE: %l\n:END:\n%U\n" )



                    ("H" "Habit" entry (file org-index-file)
                     "* TODO %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: TODO\n:END:\n")


                     ("j" "Journal")
                    ("ji" "Inaya Journal" entry (file+olp+datetree "~/Orgs/BASB/Areas/Parenting/Journal.org")
                     "** %(format-time-string \"%R\") %?  \n")

                    ("jp" "Personal Journal" entry (file+olp+datetree "~/Orgs/jrl/journal.org")
                     "** %(format-time-string \"%R\") %? \n")

                     ("c" "cooking")
                    ("cr" "Cookbook" entry (file "~/Orgs/BASB/Reference/Cookbook/cookbook.org")
                     "%(org-chef-get-recipe-from-url)"
                     :empty-lines 1)

                    ("cm" "Manual Cookbook" entry (file "~/Orgs/BASB/Reference/Cookbook/cookbook.org")
                     "* %^{Recipe title: }\n  :PROPERTIES:\n  :source-url:\n  :servings:\n  :prep-time:\n  :cook-time:\n  :ready-in:\n  :END:\n** Ingredients\n   %?\n** Directions\n\n")

              )


                    ))



#+END_SRC

#+RESULTS:
: make-capture-frame

Capture for elfeed from https://yiming.dev/blog/2016/01/28/add-org-store-link-entry-for-elfeed/
#+begin_src emacs-lisp
;; ---------------------
;; org capture in elfeed
;; ---------------------
(defun private/org-elfeed-entry-store-link ()
  (when elfeed-show-entry
    (let* ((link (elfeed-entry-link elfeed-show-entry))
           (title (elfeed-entry-title elfeed-show-entry)))
      (org-store-link-props
       :link link
       :description title)
      )))

(add-hook 'org-store-link-functions
          'private/org-elfeed-entry-store-link)
#+end_src
#+RESULTS:
| private/org-elfeed-entry-store-link |
** Encryption
#+BEGIN_SRC emacs-lisp
(setq org-crypt-disable-auto-save nil)
(require 'org-crypt)
; Encrypt all entries before saving
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
; GPG key to use for encryption
(setq org-crypt-key "51DE2D88")
#+END_SRC

#+RESULTS:
: 51DE2D88

** COMMENT Keybinds for org
#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)
#+END_SRC

* Mail setup
** Mu4e
#+BEGIN_SRC emacs-lisp

(after! mu4e
;; spell check
(add-hook 'mu4e-compose-mode-hook 'flyspell-mode)



(global-set-key (kbd "<f2>") 'mu4e)


(setq mu4e-compose-signature-auto-include t)


;; setup some handy shortcuts
;; you can quickly switch to your Inbox -- press ``ji''
;; then, when you want archive some messages, move them to
;; the 'All Mail' folder by pressing ``ma''.
(setq mu4e-maildir-shortcuts
      '( ("/Chalmers/Inbox"               . ?i)
         ("/Personal/Inbox"   . ?p)
         ("/Chalmers/Drafts" . ?d)
         ("/Personal/Drafts". ?D)
         ("/Chalmers/Trash"       . ?t)
         ("/Chalmers/All Mail"    . ?a)))



(require 'starttls)
(setq mu4e-enable-mode-line t)
(setq mu4e-contexts
      `(, (make-mu4e-context
           :name "w ashfaqf@chalmers.se"
           :enter-func (lambda () (mu4e-message "Enter ashfaqf@chalmers.se context"))
           :leave-func (lambda () (mu4e-message "Leave ashfaqf@chalmers.se context"))
           ;; we match based on the contact-fields of the message (that we are replying to)
           ;; https://www.djcbsoftware.nl/code/mu/mu4e/What-are-contexts.html#What-are-contexts
           :match-func (lambda (msg)
                         (when msg
                           (mu4e-message-contact-field-matches msg
                                                               :to "ashfaqf@chalmers.se")))
           :vars '( ( user-mail-address      . "ashfaqf@chalmers.se"  )
                    ( user-full-name         . "Ashfaq Farooqui" )
                    ( mu4e-drafts-folder .  "/Chalmers/Drafts")
                    ( mu4e-sent-folder  . "/Chalmers/Sent")
                    ( mu4e-trash-folder . "/Chalmers/Trash")
                    ( mu4e-attachment-dir . "~/Documents/MailAttachments/Chalmers")
                    ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
                    (setq mu4e-sent-messages-behavior 'delete)
                    ( smtpmail-smtp-server   . "localhost" )
                    ( smtpmail-smtp-service . 1025)
                    ;;      ( mu4e-compose-signature .
                    ;;                              "//Ashfaq")
                    ))

          ,(make-mu4e-context
            :name "p ashfaq@ashfaqfarooqui.me"
            :enter-func (lambda () (mu4e-message "Enter ashfaq@ashfaqfarooqui.me context"))
            ;; no leave-func
            ;; we match based on the contact-fields of the message
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches msg
                                                                :to "ashfaq@ashfaqfarooqui.me")))
            :vars '( ( user-mail-address       . "ashfaq@ashfaqfarooqui.me" )
                     ( user-full-name          . "Ashfaq Farooqui" )
                     (smtpmail-smtp-user . "ashfaq.farooqui@mailbox.org")
                     (mu4e-sent-messages-behavior . sent)
                     (mu4e-attachment-dir . "~/Documents/MailAttachments/Personal")
                     ( mu4e-drafts-folder . "/Personal/Drafts")
                     ( mu4e-sent-folder  . "/Personal/Sent")
                     ( mu4e-trash-folder . "/Personal/Trash")
                     (mu4e-refile-folder . "/Personal/Archive")
                     (smtpmail-smtp-server . "smtp.mailbox.org")
                     (smtpmail-stream-type . ssl )
                     (smtpmail-smtp-service . 465)))

          ))
(setq smtpmail-debug-verb t)


(setq mu4e-compose-signature message-signature)


)
#+END_SRC

#+RESULTS:
: t

** MU4e attachements
#+BEGIN_SRC emacs-lisp

       ;;;Taking the below from [[http://mbork.pl/2016-02-06_An_attachment_reminder_in_mu4e]]
(after! mu4e
    (defun mbork/message-attachment-present-p ()
      "Return t if an attachment is found in the current message."
      (save-excursion
        (save-restriction
          (widen)
          (goto-char (point-min))
          (when (search-forward "<#part" nil t) t))))

    (defcustom mbork/message-attachment-intent-re
      (regexp-opt '("I attach"
                    "I have attached"
                    "I've attached"
                    "I have included"
                    "I've included"
                    "see the attached"
                    "see the attachment"
                    "attached file"))
      "A regex which - if found in the message, and if there is no
    attachment - should launch the no-attachment warning.")

    (defcustom mbork/message-attachment-reminder
      "Are you sure you want to send this message without any attachment? "
      "The default question asked when trying to send a message
    containing `mbork/message-attachment-intent-re' without an
    actual attachment.")

    (defun mbork/message-warn-if-no-attachments ()
      "Ask the user if s?he wants to send the message even though
    there are no attachments."
      (when (and (save-excursion
                   (save-restriction
                     (widen)
                     (goto-char (point-min))
                     (re-search-forward mbork/message-attachment-intent-re nil t)))
                 (not (mbork/message-attachment-present-p)))
        (unless (y-or-n-p mbork/message-attachment-reminder)
          (keyboard-quit))))

    (add-hook 'message-send-hook #'mbork/message-warn-if-no-attachments)


)
#+END_SRC

** org-msg
#+begin_src emacs-lisp
(use-package! org-msg
  :after mu4e
:config
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil"
	org-msg-startup "hidestars indent inlineimages"
	org-msg-greeting-fmt "\nHi *%s*,\n\n"
	org-msg-greeting-name-limit 3
	org-msg-signature "



 ,#+begin_signature
 //Ashfaq
 ,#+end_signature")
 (org-msg-mode)
)
#+end_src

* GTD and PARA
Inspired from https://github.com/mwfogleman/.emacs.d/blob/master/michael.org
** Projects
A project is “any outcome that will take more than one action step to complete.” As a result of implementing Tiago Forte’s “PARA” system, I can ensure that I always have an up to date project list.
#+begin_src emacs-lisp
(defun go-to-projects ()
  (interactive)
  (find-file org-basb-main-file)
  (widen)
  (beginning-of-buffer)
  (re-search-forward "* Projects")
  (beginning-of-line))

(defun project-overview ()
  (interactive)
  (go-to-projects)
  (org-narrow-to-subtree)
  (org-sort-entries t ?p)
  (org-columns))

(defun project-deadline-overview ()
  (interactive)
  (go-to-projects)
  (org-narrow-to-subtree)
  (org-sort-entries t ?d)
  (org-columns))

#+end_src
The concept of Stuck Projects comes from David Allen’s GTD. A stuck project is a project without any action steps or tasks associated with it.

Org-Mode has the ability to tell you which subtrees don’t have tasks associated with them. You can also configure what it recognizes as a stuck project. Unfortunately, by default, this functionality picks up a lot of noise.

This function creates an agenda of stuck projects that is restricted to my “Projects” subtree.
#+begin_src emacs-lisp
(defun my-org-agenda-list-stuck-projects ()
  (interactive)
  (go-to-projects)
  (org-agenda nil "#" 'subtree))

#+end_src

** Areas
#+begin_src emacs-lisp
(defun go-to-areas ()
    (interactive)
    (find-file org-basb-main-file)
    (widen)
    (beginning-of-buffer)
    (re-search-forward "* Areas")
    (beginning-of-line))

(defun areas-overview ()
    (interactive)
    (go-to-areas)
    (org-narrow-to-subtree)
    (org-columns))

#+end_src

** Reviews
#+begin_src emacs-lisp
(defun my-new-daily-review ()
  (interactive)
  (let ((org-capture-templates '(("d" "Review: Daily Review" entry (file+olp+datetree "/tmp/reviews.org")
                                  (file "~/.doom.d/templates/dailyreviewtemplate.org")))))
    (progn
      (org-capture nil "d")
      (org-capture-finalize t)
      (org-speed-move-safe 'outline-up-heading)
      (org-narrow-to-subtree)
      (fetch-calendar)
      (org-clock-in))))

(defun my-new-weekly-review ()
  (interactive)
  (let ((org-capture-templates '(("w" "Review: Weekly Review" entry (file+olp+datetree "/tmp/reviews.org")
                                  (file "~/.doom.d/templates/weeklyreviewtemplate.org")))))
    (progn
      (org-capture nil "w")
      (org-capture-finalize t)
      (org-speed-move-safe 'outline-up-heading)
      (org-narrow-to-subtree)
      (fetch-calendar)
      (org-clock-in))))

(defun my-new-monthly-review ()
  (interactive)
  (let ((org-capture-templates '(("m" "Review: Monthly Review" entry (file+olp+datetree "/tmp/reviews.org")
                                  (file "~/.doom.d/templates/monthlyreviewtemplate.org")))))
    (progn
      (org-capture nil "m")
      (org-capture-finalize t)
      (org-speed-move-safe 'outline-up-heading)
      (org-narrow-to-subtree)
      (fetch-calendar)
      (org-clock-in))))


(bind-keys :prefix-map review-map
           :prefix "C-z d"
           ("d" . my-new-daily-review)
           ("w" . my-new-weekly-review)
           ("m" . my-new-monthly-review))

(f-touch "/tmp/reviews.org")




#+end_src

#+RESULTS:
: t

* Keycast mode
#+BEGIN_SRC emacs-lisp
(use-package! keycast
  :commands keycast-mode
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast-mode-line-update t)
          (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast-mode-line-update)
      (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
                      :height 0.9)
    '(keycast-key :inherit custom-modified
                  :height 1.1
                  :weight bold)))


#+END_SRC

* Personal keymap
#+begin_src emacs-lisp
  ;; set up my own map
  (define-key z-map (kbd "g") 'magit-status)
  (define-key z-map (kbd "e") 'elfeed)
  (define-key z-map (kbd "m") 'mu4e)
;  (define-key z-map (kbd "h p") 'hydra-pdftools/body)
;  (define-key z-map (kbd "w") 'hydra-frame-window/body)
;  (define-key z-map (kbd "h o") 'hydra-global-org/body)
;  (define-key z-map (kbd "p") 'hydra-projectile/body)
  (define-key z-map (kbd "h c") 'hydra-multiple-cursors/body)
;  (define-key z-map (kbd "h g") 'hydra-git-gutter/body)
;  (define-key z-map (kbd "h m") 'hydra-mu4e-headers/body)
;  (define-key z-map (kbd "h i") 'hydra-ivy/body)
;  (define-key z-map (kbd "a") 'hydra-avy/body)
  (define-key z-map (kbd "l") 'hydra-lsp/body)
;  (define-key z-map (kbd "j") 'hydra-dumb-jump/body)
;  (define-key z-map (kbd "z") 'hydra-zoom/body)
;  (define-key z-map (kbd "n") #'narrow-or-widen-dwim)
#+end_src

#+RESULTS:
: narrow-or-widen-dwim

* Loading complete
#+BEGIN_SRC emacs-lisp
(alert "Emacs has started")
#+END_SRC
#+RESULTS:
